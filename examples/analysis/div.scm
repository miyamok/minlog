;; 2021-02-25.  examples/analysis/div.scm

;; (load "~/git/minlog/init.scm")

;; (set! COMMENT-FLAG #f)
;; (libload "nat.scm")
;; (libload "list.scm")
;; (libload "pos.scm")
;; (libload "int.scm")
;; (libload "rat.scm")
;; (remove-var-name "x" "y" "z")
;; (libload "rea.scm")
;; ;; (set! COMMENT-FLAG #t)

(display "loading div.scm ...") (newline)

;; DivAuxBdR
(set-goal "all x,y(0<<=x -> x<<=y -> abs(4*((1#2)*(x+ ~((1#2)*y))))<<=y)")
(assume "x" "y" "0<<=x" "x<<=y")
(simpreal "RealAbsTimes")
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "RealTimesAssoc")
(ng #t)
(use "RealLeTrans" (pt "2*((1#2)*y)"))
(use "RealLeMonTimesR")
(use "RatLeToRealLe")
(use "Truth")
;; ?_18:abs(x+ ~((1#2)*y))<<=(1#2)*y
(use "RealLeAbs")
;; 19,20
;; ?_19:x+ ~((1#2)*y)<<=(1#2)*y
(use "RealLeTrans" (pt "y+ ~((1#2)*y)"))
(use "RealLeMonPlusTwo")
(use "x<<=y")
(use "RealLeRefl")
(autoreal)
(simpreal "RealPlusComm")
(use "RealLePlusRInv")
(autoreal)
(simpreal "<-" "RealTimesPlusDistr")
(assert "y+y===2*y")
 (simpreal (pf "2*y===(RealPlus 1 1)*y"))
 (simpreal "RealTimesPlusDistrLeft")
 (simpreal "RealOneTimes")
 (use "RealEqRefl")
 (autoreal)
 (ng)
 (use "RealEqRefl")
 (autoreal)
(assume "y+y===2*y")
(simpreal "y+y===2*y")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealLeRefl")
(autoreal)
;; ?^21:~(x+ ~((1#2)*y))<<=(1#2)*y
(simpreal "RealUMinusPlus")
(simpreal "RealUMinusUMinus")
(use "RealLePlusRInv")
(autoreal)
(use "RealLeTrans" (pt "0+(1#2)*y"))
(simpreal "RealPlusComm")
(simpreal "RealPlusZero")
(use "RealLeRefl")
(autoreal)
(use "RealLeMonPlus")
(autoreal)
(use "0<<=x")
(autoreal)
;; ?^16:2*((1#2)*y)<<=y
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealLeRefl")
(autoreal)
;; Proof finished.
(save "DivAuxBdR")

;; DivAuxBdL
(set-goal "all x,y(x<<=0 -> abs x<<=y -> abs(4*((1#2)*(x+(1#2)*y)))<<=y)")
(assume "x" "y" "x<<=0" "abs x<<=y")
(simpreal "RealAbsTimes")
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "RealTimesAssoc")
(ng #t)
(use "RealLeTrans" (pt "2*((1#2)*y)"))
(use "RealLeMonTimesR")
(use "RatLeToRealLe")
(use "Truth")
;; ?^18:abs(x+(1#2)*y)<<=(1#2)*y
(use "RealLeAbs")
;; 20,21
;; ?^20:x+(1#2)*y<<=(1#2)*y
(use "RealLeTrans" (pt "0+(1#2)*y"))
(use "RealLeMonPlus")
(autoreal)
(use "x<<=0")
(simpreal "RealPlusComm")
(simpreal "RealPlusZero")
(use "RealLeRefl")
(autoreal)
;; ?^21:~(x+(1#2)*y)<<=(1#2)*y
(simpreal "RealPlusComm")
(simpreal "RealUMinusPlus")
(use "RealLePlusRInv")
(autoreal)
(simpreal "<-" "RealTimesPlusDistr")
(use "RealLeTrans" (pt "abs ~x"))
(use "RealLeIdAbs")
(autoreal)
(simpreal "RealAbsUMinus")
(use "RealLeTrans" (pt "y"))
(use "abs x<<=y")
;; ?^51:y<<=(1#2)*(y+y)
(assert "y+y===2*y")
 (simpreal (pf "2*y===(RealPlus 1 1)*y"))
 (simpreal "RealTimesPlusDistrLeft")
 (simpreal "RealOneTimes")
 (use "RealEqRefl")
 (autoreal)
 (ng)
 (use "RealEqRefl")
 (autoreal)
(assume "y+y===2*y")
(simpreal "y+y===2*y")
(simpreal "RealTimesAssoc")
(ng)
(simpreal "RealOneTimes")
(use "RealLeRefl")
(autoreal)
;; ?_16:2*((1#2)*y)<<=y
(simpreal "RealTimesAssoc")
(ng)
(simpreal "RealOneTimes")
(use "RealLeRefl")
(autoreal)
;; Proof finished.
(save "DivAuxBdL")

;; DivAuxEqR
(set-goal "all x,y(Real x -> Real y -> (1#4)<<=y ->
 x*RealUDiv y 3===(1#2)*(4*((1#2)*(x+ ~((1#2)*y)))*RealUDiv y 3+1))")
(assume "x" "y" "Rx" "Ry" "yLBd")
(assert "RealPos y 3")
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (ng #t)
 (use "yLBd")
 (use "Truth")
(assume "RealLeToPosInst")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealTimesPlusDistr")
(ng #t)
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "<-" "RealTimesIdUMinus")
(simpreal (pf "(1#2)* ~y*RealUDiv y 3===RealUMinus(1#2)*y*RealUDiv y 3"))
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesUDivR")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqTrans" (pt "x*RealUDiv y 3+RealPlus(IntN 1#2)(1#2)"))
(ng #t)
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(simpreal "<-" "RealPlusAssoc")
(use "RealEqRefl")
(autoreal)
(use "RealLeToPosInst")
(autoreal)
;; ?^41:(1#2)* ~y*RealUDiv y 3=== ~(1#2)*y*RealUDiv y 3
(use "RealTimesCompat")
(simpreal "RealTimesUMinusId")
(simpreal "RealTimesIdUMinus")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "DivAuxEqR")

;; DivAuxEqL
(set-goal "all x,y(Real x -> Real y -> (1#4)<<=y ->
 x*RealUDiv y 3===(1#2)*(4*((1#2)*(x+(1#2)*y))*RealUDiv y 3+IntN 1))")
(assume "x" "y" "Rx" "Ry" "yLBd")
(assert "RealPos y 3")
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (ng #t)
 (use "yLBd")
 (use "Truth")
(assume "RealLeToPosInst")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealTimesPlusDistr")
(ng #t)
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesUDivR")
(ng #t)
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(use "RealLeToPosInst")
(autoreal)
;; Proof finished.
;; (cdp)
(save "DivAuxEqL")

