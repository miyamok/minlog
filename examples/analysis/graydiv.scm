;; 2017-12-12.  examples/analysis/graydiv.scm

(load "~/git/minlog/init.scm")

(set! COMMENT-FLAG #f)
(libload "nat.scm")
(libload "list.scm")
(libload "pos.scm")
(libload "int.scm")
(libload "rat.scm")
(remove-var-name "x" "y" "z")
(libload "rea.scm")
;; (set! COMMENT-FLAG #t)

(load "~/git/minlog/examples/analysis/digits.scm")
(load "~/git/minlog/examples/analysis/graycode.scm")
(load "~/git/minlog/examples/analysis/JK.scm")
(load "~/git/minlog/examples/analysis/grayavaux.scm")
(load "~/git/minlog/examples/analysis/div.scm")

;; PMOneToCoG
(set-goal "allnc x(x===1 oru x===IntN 1 -> CoG x)")
(assume "x" "PMOnex")
(coind "PMOnex" (pf "x===1 oru x===IntN 1 -> CoH x"))
(assume "x1" "Disj")
(elim "Disj")
;; 6,7
(assume "x1=1")
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "RealConstr([n](IntN 1#1))([p]Zero)"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdTrue")
(split)
(use "RealRat")
(split)
(use "RealLeRefl")
(use "RealRat")
(split)
(intro 1)
(intro 1)
(use "RealEqRefl")
(use "RealRat")
(split)
(simpreal "x1=1")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(realproof)
;; 7
(assume "x1=== ~1")
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "RealConstr([n](IntN 1#1))([p]Zero)"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdFalse")
(split)
(use "RealRat")
(split)
(use "RealLeRefl")
(use "RealRat")
(split)
(intro 1)
(intro 1)
(use "RealEqRefl")
(use "RealRat")
(split)
(simpreal "x1=== ~1")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(realproof)
;; 4
(assume "x1" "Disj")
(elim "Disj")
;; 55,56
(assume "x1=1")
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "RealConstr([n](1#1))([p]Zero)"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdTrue")
(split)
(use "RealRat")
(split)
(use "RealLeRefl")
(use "RealRat")
(split)
(intro 1)
(intro 0)
(use "RealEqRefl")
(use "RealRat")
(split)
(simpreal "x1=1")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(realproof)
;; 56
(assume "x1=== ~1")
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "RealConstr([n](1#1))([p]Zero)"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdFalse")
(split)
(use "RealRat")
(split)
(use "RealLeRefl")
(use "RealRat")
(split)
(intro 1)
(intro 0)
(use "RealEqRefl")
(use "RealRat")
(split)
(simpreal "x1=== ~1")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(realproof)
;; Proof finished.
(save "PMOneToCoG")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; [boole]
;;  (CoRec boole=>ag boole=>ah)boole
;;  ([boole0]
;;    [case boole0
;;      (True -> InL(True pair InR False))
;;      (False -> InL(False pair InR False))])
;;  ([boole0]
;;    [case boole0
;;      (True -> InL(True pair InR True))
;;      (False -> InL(False pair InR True))])

;; CoGOne
(set-goal "CoG 1")
(use "PMOneToCoG")
(intro 0)
(use "RealEqRefl")
(use "RealRat")
;; Proof finished.
(save "CoGOne")

(define eterm (proof-to-extracted-term))
(animate "PMOneToCoG")
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; (CoRec boole=>ag boole=>ah)True
;; ([boole]
;;   [case boole
;;     (True -> InL(True pair InR False))
;;     (False -> InL(False pair InR False))])
;; ([boole]
;;   [case boole
;;     (True -> InL(True pair InR True))
;;     (False -> InL(False pair InR True))])

;; CoGIntNOne
(set-goal "CoG(IntN 1)")
(use "PMOneToCoG")
(intro 1)
(use "RealEqRefl")
(use "RealRat")
;; Proof finished.
(save "CoGIntNOne")

(define eterm (proof-to-extracted-term))
(animate "PMOneToCoG")
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; (CoRec boole=>ag boole=>ah)False
;; ([boole]
;;   [case boole
;;     (True -> InL(True pair InR False))
;;     (False -> InL(False pair InR False))])
;; ([boole]
;;   [case boole
;;     (True -> InL(True pair InR True))
;;     (False -> InL(False pair InR True))])

(deanimate "PMOneToCoG")

;; CoGShiftAux1
(set-goal "all x,y(Real x -> 
 abs x<<=1 -> y===(1#2)*(x+IntN 1)* ~1 -> y<<=0 -> y===0)")
(assume "x" "y" "Rx" "xBd" "yDef" "y<=0")
(use "RealLeAntiSym")
(use "y<=0")
;; ?_4:0<<=y
(assert "x===1")
 (use "RealLeAntiSym")
 ;; 7,8
 (use "RealLeTrans" (pt "abs x"))
 (use "RealLeAbsId")
 (autoreal)
 (use "xBd")
 ;; 8
 (assert "x===2* ~y+1")
  (simpreal "yDef")
  (simpreal "RealTimesIdRatUMinus")
  (simpreal "RealTimesOne")
  (simpreal "RealUMinusUMinus")
  (simpreal "RealTimesAssoc")
  (ng #t)
  (simpreal "RealOneTimes")
  (simpreal "<-" "RealPlusAssoc")
  (ng #t)
  (simpreal "RealPlusZero")
  (use "RealEqRefl")
  (autoreal)
 (assume "xEq")
 (simpreal "xEq")
 (use "RealLeTrans" (pt "2* RealUMinus 0+1"))
 (ng #t)
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeUMinus")
 (use "y<=0")
 (use "RatLeToRealLe")
 (use "Truth")
(assume "x=1")
(simpreal "yDef")
(simpreal "x=1")
(use "RatLeToRealLe")
(use "Truth")
;; Proof finished.
(save "CoGShiftAux1")

;; CoGShiftAux2
(set-goal "all x,y(Real x -> 
 abs x<<=1 -> y===(1#2)*(x+1)*1 -> y<<=0 -> y===0)")
(assume "x" "y" "Rx" "xBd" "yDef" "y<=0")
(use "RealLeAntiSym")
(use "y<=0")
;; ?_4:0<<=y
(assert "x=== RealUMinus 1")
 (use "RealLeAntiSym")
 ;; 7,8
 (assert "x===2*y+ IntN 1")
  (simpreal "yDef")
  (simpreal "<-" "RealTimesAssoc")
  (simpreal "RealTimesOne")
  (simpreal "RealTimesAssoc")
  (ng #t)
  (simpreal "RealOneTimes")
  (simpreal "<-" "RealPlusAssoc")
  (ng #t)
  (simpreal "RealPlusZero")
  (use "RealEqRefl")
  (autoreal)
 (assume "xEq")
 (simpreal "xEq")
 (use "RealLeTrans" (pt "2* RealUMinus 0+IntN 1"))
 (use "RealLeMonPlus")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "y<=0")
 (use "RatLeToRealLe")
 (use "Truth")
 (ng #t)
 (use "RatLeToRealLe")
 (use "Truth")
;; ?_8:~1<<=x
 (simpreal (pf "x=== ~ ~x"))
 (use "RealLeUMinus")
 (use "RealLeTrans" (pt "abs ~x"))
 (use "RealLeAbsId")
 (autoreal)
 (simpreal "RealAbsUMinus")
 (use "xBd")
 (autoreal)
 (use "RealEqSym")
 (use "RealUMinusUMinus")
 (autoreal)
(assume "x= ~1")
(simpreal "yDef")
(simpreal "x= ~1")
(use "RatLeToRealLe")
(use "Truth")
;; Proof finished.
(save "CoGShiftAux2")

;; CoGShiftAux3
(set-goal "all x,y(Real x -> y===(1#2)*x -> y<<=0 -> x<<=0)")
(assume "x" "y" "Rx" "yDef" "y<=0")
(simpreal (pf "x===2*((1#2)*x)"))
(simpreal (pf "0===RealTimes 2 0"))
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(simpreal "<-" "yDef")
(use "y<=0")
(use "RatEqvToRealEq")
(use "Truth")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
(save "CoGShiftAux3")

;; CoGShiftAux4
(set-goal
 "all x,y(Real x -> abs x<<=1 -> y===(1#2)*x -> y<<=0 -> abs(x+1)<<=1)")
(assume "x" "y" "Rx" "xBd" "yDef" "y<=0")
(use "RealLeAbs")
;; ?_3:x+1<<=1
(use "RealLeTrans" (pt "RealPlus 0 1"))
(use "RealLeMonPlus")
(use "CoGShiftAux3" (pt "y"))
(use "Rx")
(use "yDef")
(use "y<=0")
(use "RatLeToRealLe")
(use "Truth") 
(use "RatLeToRealLe")
(use "Truth") 
;; ?_4:~(x+1)<<=1
(use "RealLeTrans" (pt "~(RealUMinus 1)"))
(use "RealLeUMinus")
(use "RealLeTrans" (pt "(RealUMinus 1)+1"))
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeMonPlus")
(use "RealLeAbsInv")
(use "Rx")
(use "xBd")
(use "RatLeToRealLe")
(use "Truth")
(use "RatLeToRealLe")
(use "Truth")
;; Proof finished.
(save "CoGShiftAux4")

;; (set! COMMENT-FLAG #f)
;; CoGShift
(set-goal
 "allnc x(exr y(CoG y andi y<<=0 andr (x===y+1 oru x=== ~(y+1))) -> CoG x)")
(assume "x" "Shift")
(coind "Shift"
     (pf "exr y(CoH y andi y<<=0 andr (x===y+1 oru x=== ~(y+1))) -> CoH x"))
;; 3,4
(drop "Shift")
(assume "x0" "ExHyp")
(by-assume "ExHyp" "y" "yProp")
(elim "yProp")
(drop "yProp")
(assume "CoGy")
(inst-with-to "CoGClosure" (pt "y") "CoGy" "CoGClosureInst")
(elim "CoGClosureInst")
;; 15,16
(drop "CoGClosureInst")
(assume "ExHypdx1")
(by-assume "ExHypdx1" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(elim "dx1Prop")
(drop "dx1Prop")
(assume "Psdd" "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoGx1")
(assert "abs x1<<=1")
 (use "CoGToBd")
 (use "CoGx1")
(assume "x1Bd")
(elim "Psdd")
;; 35,36
;; Case d=1
(drop "Psdd")
(assume "yDef" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "y<=0" "Disj")
(assert "y===0")
 (use "CoGShiftAux1" (pt "x1"))
 (autoreal)
 (use "x1Bd")
 (simpreal "yDef")
 (use "RealEqRefl")
 (autoreal)
 (use "y<=0")
(assume "y=0")
(elim "Disj")
;; 51,52
(drop "Disj")
;; Case x0=y+1
(assume "x0=y+1")
;; Go for lhs of the disjunction with d=1 and x= ~1
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "RealUMinus 1"))
(intro 0 (pt "y+1"))
(split)
(use "InitPsdTrue")
(split)
(autoreal)
(split)
(use "RatLeToRealLe")
(use "Truth")
(split)
(intro 0)
(use "CoGIntNOne")
(split)
(simpreal "y=0")
(ng #t)
(use "RatEqvToRealEq")
(use "Truth")
(use "x0=y+1")
;; 52
(drop "Disj")
;; Case x0= ~(y+1)
(assume "x0= ~(y+1)")
;; Go for lhs of the disjunction with d=IntN 1 and x=RealUMinus 1
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "RealUMinus 1"))
(intro 0 (pt "~(y+1)"))
(split)
(use "InitPsdFalse")
(split)
(autoreal)
(split)
(use "RatLeToRealLe")
(use "Truth")
(split)
(intro 0)
(use "CoGIntNOne")
(split)
(simpreal "y=0")
(ng #t)
(use "RatEqvToRealEq")
(use "Truth")
(use "x0= ~(y+1)")
;; 36
;; Case d=IntN 1
(drop "Psdd")
(assume "yDef" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "y<=0" "Disj")
(elim "Disj")
;; 100,101
(drop "Disj")
(assume "x0=y+1")
;; Go for lhs of the disjunction with d=1 and x= ~x1
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "~x1"))
(intro 0 (pt "y+1"))
(split)
(use "InitPsdTrue")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "x1Bd")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGx1")
(autoreal)
(split)
(simpreal (pf "y+1===y+RealTimes(1#2)2"))
(simpreal "yDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(ng #t)
(simpreal "RealTimesOne")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusPlusRat")
(simpreal "RealUMinusUMinus")
(ng #t)
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(use "RealEqRefl")
(autoreal)
(ng #t)
(use "RealEqRefl")
(autoreal)
(simpreal "x0=y+1")
(use "RealEqRefl")
(autoreal)
;; 101
(drop "Disj")
(assume "x0= ~(y+1)")
;; Go for lhs of the disjunction with d=IntN 1 and x= ~x1
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "~x1"))
(intro 0 (pt "~(y+1)"))
(split)
(use "InitPsdFalse")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "x1Bd")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGx1")
(autoreal)
(split)
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusDistrLeft")
(ng #t)
(simpreal "RealTimesOne")
(simpreal (pf "~(y+1)=== ~(y+RealTimes(1#2)2)"))
(simpreal "yDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(ng #t)
(simpreal "RealTimesOne")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "<-" "RealTimesIdUMinus")
(simpreal "RealUMinusPlusRat")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "x0= ~(y+1)")
;; 16
(drop "CoGClosureInst")
(assume "ExHypx1")
(by-assume "ExHypx1" "x1" "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoHx1" "yDef" "Conj1")
(assert "abs x1<<=1")
 (use "CoHToBd")
 (use "CoHx1")
(assume "x1Bd")
(elim "Conj1")
(drop "Conj1")
(assume "y<=0" "Disj")
;; Case y<=0
(assert "x1<<=0")
 (use "CoGShiftAux3" (pt "y"))
 (autoreal)
 (use "yDef")
 (use "y<=0")
(assume "x1<=0")
(assert "abs(x1+1)<<=1")
 (use "CoGShiftAux4" (pt "y"))
 (autoreal)
 (use "x1Bd")
 (use "yDef")
 (use "y<=0")
(assume "abs(x1+1)<=1")
(elim "Disj")
;; 246,247
(drop "Disj")
;; Case x0=y+1
(assume "x0=y+1")
;; Go for lhs of the disjunction with d=1 and x= ~(x1+1)
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "~(x1+1)"))
(intro 0 (pt "y+1"))
(split)
(use "InitPsdTrue")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "abs(x1+1)<=1")
(autoreal)
(split)
(intro 1)
(intro 0 (pt "x1"))
(split)
(use "CoHToCoG")
(use "CoHx1")
(split)
;; ?_269:x1<<=0
(use "x1<=0")
;; ?_270:~(x1+1)===x1+1 oru ~(x1+1)=== ~(x1+1)
(intro 1)
(use "RealEqRefl")
(autoreal)
(split)
;; ?_273:y+1===(1#2)*(~(x1+1)+IntN 1)* ~1
(simpreal "<-" "RealTimesAssoc")
(ng #t)
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusPlusRat")
(simpreal "RealUMinusUMinus")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealTimesPlusDistr")
(ng #t)
(simpreal "yDef")
(use "RealEqRefl")
(autoreal)
(use "x0=y+1")
;; 247
(drop "Disj")
;; Case x0= ~(y+1)
(assume "x0= ~(y+1)")
;; Go for lhs of the disjunction with d=IntN 1 and x= ~(x1+1)
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "~(x1+1)"))
(intro 0 (pt "~(y+1)"))
(split)
(use "InitPsdFalse")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "abs(x1+1)<=1")
(autoreal)
(split)
(intro 1)
(intro 0 (pt "x1"))
(split)
(use "CoHToCoG")
(use "CoHx1")
(split)
(use "x1<=0")
(intro 1)
(use "RealEqRefl")
(autoreal)
(split)
(ng #t)
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simpreal (pf "~(x1+1)=== ~x1+RealUMinus 1"))
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealTimesPlusDistr")
(ng #t)
(simpreal "RealUMinusPlusRat")
(simpreal "yDef")
(simpreal "RealTimesIdUMinus")
(use "RealEqRefl")
(autoreal)
(simpreal "RealUMinusPlusRat")
(use "RealEqRefl")
(autoreal)
(use "x0= ~(y+1)")
;; 4
(drop "Shift")
(assume "x0" "ExHyp")
(by-assume "ExHyp" "y" "yProp")
(elim "yProp")
(drop "yProp")
(assume "CoHy")
(inst-with-to "CoHClosure" (pt "y") "CoHy" "CoHClosureInst")
(elim "CoHClosureInst")
;; 364,365
(drop "CoHClosureInst")
(assume "ExHypdx1")
(by-assume "ExHypdx1" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(elim "dx1Prop")
(drop "dx1Prop")
(assume "Psdd" "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoGx1")
(assert "abs x1<<=1")
 (use "CoGToBd")
 (use "CoGx1")
(assume "x1Bd")
(elim "Psdd")
;; 384,385
;; Case d=1
(drop "Psdd")
(assume "yDef" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "y<=0" "Disj")
(assert "y===0")
 (use "CoGShiftAux2" (pt "x1"))
 (autoreal)
 (use "x1Bd")
 (simpreal "yDef")
 (use "RealEqRefl")
 (autoreal)
 (use "y<=0")
(assume "y=0")
(elim "Disj")
;; 400,401
(drop "Disj")
;; Almost the same situation as in goal 51.  But here (1#2)*(x+1)*d
(assume "x0=y+1")
;; Go for lhs of the disjunction with d=1 and x=1
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "RealConstr([n]1#1)([p]Zero)"))
(intro 0 (pt "y+1"))
(split)
(use "InitPsdTrue")
(split)
(autoreal)
(split)
(use "RatLeToRealLe")
(use "Truth")
(split)
(intro 0)
(use "CoGOne")
(split)
(simpreal "y=0")
(ng #t)
(use "RatEqvToRealEq")
(use "Truth")
(use "x0=y+1")
;; 401
(drop "Disj")
;; Case x0= ~(y+1)
(assume "x0= ~(y+1)")
;; Go for lhs of the disjunction with d=IntN 1 and x=1
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "RealConstr([n]1#1)([p]Zero)"))
(intro 0 (pt "~(y+1)"))
(split)
(use "InitPsdFalse")
(split)
(autoreal)
(split)
(use "RatLeToRealLe")
(use "Truth")
(split)
(intro 0)
(use "CoGOne")
(split)
(simpreal "y=0")
(ng #t)
(use "RatEqvToRealEq")
(use "Truth")
(use "x0= ~(y+1)")
;; 385
;; Case d=IntN 1
(drop "Psdd")
(assume "yDef" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "y<=0" "Disj")
(elim "Disj")
;; 449,450
(drop "Disj")
(assume "x0=y+1")
;; Go for lhs of the disjunction with d=1 and x= ~x1
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "~x1"))
(intro 0 (pt "y+1"))
(split)
(use "InitPsdTrue")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "x1Bd")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGx1")
(autoreal)
(split)
(simpreal (pf "y+1===y+RealTimes(1#2)2"))
(simpreal "yDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusPlusRat")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(simpreal "x0=y+1")
(use "RealEqRefl")
(autoreal)
;; 450
(drop "Disj")
;; Case x0= ~(y+1)
(assume "x0= ~(y+1)")
;; Go for lhs of the disjunction with d=IntN 1 and x= ~x1
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "~x1"))
(intro 0 (pt "~(y+1)"))
(split)
(use "InitPsdFalse")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "x1Bd")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGx1")
(autoreal)
(split)
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusDistrLeft")
(ng #t)
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusUMinus")
(simpreal (pf "~(y+1)=== ~(y+RealTimes(1#2)2)"))
(simpreal "yDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusPlusRat")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "<-" "RealTimesIdUMinus")
(simpreal "RealUMinusPlusRat")
(simpreal "RealUMinusUMinus")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "x0= ~(y+1)")
;; 365
(drop "CoHClosureInst")
(assume "ExHypx1")
(by-assume "ExHypx1" "x1" "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoHx1")
(assert "abs x1<<=1")
 (use "CoHToBd")
 (use "CoHx1")
(assume "x1Bd" "yDef" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "y<=0" "Disj")
;; Case y<=0
(elim "Disj")
;; 582,583
(drop "Disj")
;; Case x0=y+1
(assume "x0=y+1")
;; Go for lhs of the disjunction with d=1 and x=x1+1
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "x1+1"))
(intro 0 (pt "y+1"))
(split)
(use "InitPsdTrue")
(split)
(autoreal)
(split)
(use "CoGShiftAux4" (pt "y"))
(autoreal)
(use "x1Bd")
(use "yDef")
(use "y<=0")
(split)
(intro 1)
(intro 0 (pt "x1"))
(split)
(use "CoHToCoG")
(use "CoHx1")
(split)
(use "CoGShiftAux3" (pt "y"))
(autoreal)
(use "yDef")
(use "y<=0")
(intro 0)
(use "RealEqRefl")
(autoreal)
(split)
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealTimesPlusDistr")
(ng #t)
(simpreal "yDef")
(use "RealEqRefl")
(autoreal)
(use "x0=y+1")
;; 613
(drop "Disj")
;; Case x0= ~(y+1)
(assume "x0= ~(y+1)")
;; Go for lhs of the disjunction with d=IntN 1 and x=(x1+1)
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "x1+1"))
(intro 0 (pt "~(y+1)"))
(split)
(use "InitPsdFalse")
(split)
(autoreal)
(split)
(use "CoGShiftAux4" (pt "y"))
(autoreal)
(use "x1Bd")
(use "yDef")
(use "y<=0")
(split)
(intro 1)
(intro 0 (pt "x1"))
(split)
(use "CoHToCoG")
(use "CoHx1")
(split)
(use "CoGShiftAux3" (pt "y"))
(autoreal)
(use "yDef")
(use "y<=0")
(intro 0)
(use "RealEqRefl")
(autoreal)
(split)
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesIntNOne")
(simpreal "RealTimesIdUMinus")
(simpreal "RealTimesPlusDistr")
(simpreal "yDef")
(use "RealEqRefl")
(autoreal)
(use "x0= ~(y+1)")
;; Proof finished.
(save "CoGShift")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; [(ag yprod boole)]
;;  (CoRec ag yprod boole=>ag ah yprod boole=>ah)(ag yprod boole)
;;  ([(ag yprod boole)_0]
;;    [case (ag yprod boole)_0
;;      (ag pair boole -> 
;;      [case (cCoGClosure ag)
;;        (InL bg -> 
;;        [case bg
;;          (boole0 pair ag0 -> 
;;          [case boole0
;;            (True -> 
;;            [case boole
;;              (True -> InL(True pair InL cCoGIntNOne))
;;              (False -> InL(False pair InL cCoGIntNOne))])
;;            (False -> 
;;            [case boole
;;              (True -> InL(True pair InL(cCoGUMinus(cCoGCompat ag0))))
;;              (False -> InL(False pair InL(cCoGUMinus(cCoGCompat ag0))))])])])
;;        (InR ah -> 
;;        [case boole
;;          (True -> InL(True pair InR(cCoHToCoG ah pair False)))
;;          (False -> InL(False pair InR(cCoHToCoG ah pair False)))])])])
;;  ([(ah yprod boole)]
;;    [case (ah yprod boole)
;;      (ah pair boole -> 
;;      [case (cCoHClosure ah)
;;        (InL bg -> 
;;        [case bg
;;          (boole0 pair ag -> 
;;          [case boole0
;;            (True -> 
;;            [case boole
;;              (True -> InL(True pair InL cCoGOne))
;;              (False -> InL(False pair InL cCoGOne))])
;;            (False -> 
;;            [case boole
;;              (True -> InL(True pair InL(cCoGUMinus(cCoGCompat ag))))
;;              (False -> InL(False pair InL(cCoGUMinus(cCoGCompat ag))))])])])
;;        (InR ah0 -> 
;;        [case boole
;;          (True -> InL(True pair InR(cCoHToCoG ah0 pair True)))
;;          (False -> InL(False pair InR(cCoHToCoG ah0 pair True)))])])])

;; (set! COMMENT-FLAG #t)
(dcg)

;; As corollaries we obtain
;; CoGNegToCoGPlusOne
(set-goal "allnc x(exr y(CoG y andi y<<=0 andi x===y+1) -> CoG x)")
(assume "x" "ExHyp")
(by-assume "ExHyp" "y" "yProp")
(elim "yProp")
(drop "yProp")
(assume "CoGy" "Conj")
(elim "Conj")
(drop "Conj")
(assume "y<=0" "x=y+1")
(use "CoGShift")
(intro 0 (pt "y"))
(split)
(use "CoGy")
(split)
(use "y<=0")
(intro 0)
(use "x=y+1")
;; Proof finished.
(save "CoGNegToCoGPlusOne")

(define eterm (proof-to-extracted-term))
(animate "CoGShift")
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; As for CoGShift, but with (ag pair True) rather than (ag pair boole)
;; as CoRec argument

(deanimate "CoGShift")

;; CoGPosToCoGMinusOne
(set-goal "allnc x(exr y(CoG y andi 0<<=y andi x===y+ ~1) -> CoG x)")
(assume "x" "ExHyp")
(by-assume "ExHyp" "y" "yProp")
(elim "yProp")
(drop "yProp")
(assume "CoGy" "Conj")
(elim "Conj")
(drop "Conj")
(assume "y<=0" "x=y+ ~1")
(use "CoGShift")
(intro 0 (pt "~y"))
(split)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGy")
(autoreal)
(split)
(use "RealLeUMinusInv")
(simpreal "RealUMinusUMinus")
(use "y<=0")
(autoreal)
(intro 1)
(simpreal "RealUMinusPlusRat")
(simpreal "RealUMinusUMinus")
(use "x=y+ ~1")
(autoreal)
;; Proof finished.
(save "CoGPosToCoGMinusOne")

(define eterm (proof-to-extracted-term))
(animate "CoGShift")
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; As for CoGShift, but with (cCoGUMinus(cCoGCompat ag)pair False)
;; rather than (ag pair boole) as CoRec argument

(deanimate "CoGShift")

;; CoGToCoGDouble
(set-goal "allnc x(CoG x -> abs x<<=(1#2) -> CoG(2*x))")
(assume "x" "CoGx" "LeHyp")
(inst-with-to "CoGClosure" (pt "x") "CoGx" "CoGClosureInst")
(elim "CoGClosureInst")
;; 5,6
(drop "CoGClosureInst")
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(elim "dx1Prop")
(drop "dx1Prop")
(assume "Psdd")
(elim "Psdd")
;; 18,19
;; Case d=1
(assume "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoGx1" "xDef")
(simpreal "xDef")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealTimesIntNOne")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(simpreal "RealUMinusPlusRat")
(ng #t)
(use "CoGNegToCoGPlusOne")
(intro 0 (pt "~x1"))
(split)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGx1")
(autoreal)
(split)
;;   {x}  CoGx:CoG x
;;   LeHyp:abs x<<=(1#2)
;;   {d}  {x1}  Psdd:Psd d
;;   CoGx1:CoG x1
;;   xDef:x===(1#2)*(x1+IntN 1)* ~1
;; -----------------------------------------------------------------------------
;; ?_49:~x1<<=0
(use "RealLeTrans" (pt "2*((1#2)*(x1+IntN 1)* ~1)+ ~1"))
;; 51,52
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "RealTimesIdRatUMinus")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesOne")
(ng #t)
(simpreal "RealOneTimes")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealPlusZero")
(use "RealLeRefl")
(autoreal)
;; 52
(simpreal "<-" "xDef")
(use "RealLeTrans" (pt "2*abs x+ ~1"))
(use "RealLeMonPlus")
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "RealLeAbsId")
(autoreal)
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeTrans" (pt "RealTimes 2(1#2)+ ~1"))
(use "RealLeMonPlus")
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "LeHyp")
(use "RatLeToRealLe")
(use "Truth")
(ng #t)
(use "RatLeToRealLe")
(use "Truth")
(use "RealEqRefl")
(autoreal)
;; 19
;; Case d= ~1
(ng #t)
(assume "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoGx1" "xDef")
(simpreal "xDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "CoGPosToCoGMinusOne")
(intro 0 (pt "x1"))
(split)
(use "CoGx1")
(split)
;;   {x}  CoGx:CoG x
;;   LeHyp:abs x<<=(1#2)
;;   {d}  {x1}  Psdd:Psd d
;;   CoGx1:CoG x1
;;   xDef:x===(1#2)*(x1+IntN 1)*1
;; -----------------------------------------------------------------------------
;; ?_124:0<<=x1
(use "RealLeTrans" (pt "2*((1#2)*(x1+IntN 1)*1)+ 1"))
;; 126,127
(simpreal "<-" "xDef")
(use "RealLeTrans" (pt "2*RealUMinus(1#2)+1"))
(ng #t)
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeMonPlus")
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "RealLeAbsInv")
(autoreal)
(use "LeHyp")
(use "RatLeToRealLe")
(use "Truth")
;; 127
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealPlusZero")
(use "RealLeRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; ?_6:exr x0(CoH x0 andl x===(1#2)*x0) -> CoG(2*x)
(drop "CoGClosureInst")
(assume "ExHyp")
(by-assume "ExHyp" "x1" "Conj")
(elim "Conj")
(assume "CoHx1" "xDef")
(drop "Conj")
(simpreal "xDef")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "CoHToCoG")
(use "CoHx1")
(autoreal)
;; Proof finished.
(save "CoGToCoGDouble")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; [ag][case (cCoGClosure ag)
;;    (InL bg -> [case bg
;;      (boole pair ag0 -> [case boole
;;        (True -> 
;;        cCoGCompat
;;        (cCoGCompat
;;         (cCoGCompat
;;          (cCoGCompat
;;           (cCoGCompat
;;            (cCoGCompat(cCoGNegToCoGPlusOne(cCoGUMinus(cCoGCompat ag0)))))))))
;;        (False -> 
;;        cCoGCompat
;;        (cCoGCompat
;;         (cCoGCompat(cCoGCompat(cCoGCompat(cCoGPosToCoGMinusOne ag0))))))])])
;;    (InR ah -> cCoGCompat(cCoGCompat(cCoGCompat(cCoHToCoG ah))))]

;; CoGToCoGQuad
(set-goal "allnc x(CoG x -> abs x<<=(1#4) -> CoG(4*x))")
(assume "x" "CoGx" "LeHyp")
(assert "4*x===2*(2*x)")
(simpreal "RealTimesAssoc")
(ng #t)
(use "RealEqRefl")
(autoreal)
;; Assertion proved
(assume "EqHyp")
(simpreal "EqHyp")
(use "CoGToCoGDouble")
(use "CoGToCoGDouble")
(use "CoGx")
(use "RealLeTrans" (pt "RealPlus 0(1#4)"))
(ng #t)
(use "LeHyp")
(ng #t)
(use "RatLeToRealLe")
(use "Truth")
(simpreal "RealAbsTimes")
(ng #t)
(use "RealLeTrans" (pt "RealTimes 2(1#4)"))
(use "RealLeMonTimes")
(use "RealNNegPos")
(use "LeHyp")
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
;; Proof finished.
(save "CoGToCoGQuad")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(pp neterm)

;; [ag]cCoGCompat(cCoGToCoGDouble(cCoGToCoGDouble ag))

;; CoGDivSatCoIClAuxR
(set-goal "allnc x,y(CoG x -> CoG y -> (1#4)<<=y -> abs x<<=y -> 0<<=x -> 
 CoG(4*((1#2)*(x+ ~((1#2)*y)))))")
(assume "x" "y" "CoGx" "CoGy" "yLBd" "xBd" "0<<=x")
(use "CoGToCoGQuad")
(use "CoGAverage")
(use "CoGx")
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGClosureInvH")
(use "CoGToCoH")
(use "CoGy")
(autoreal)
;; ?_4:abs((1#2)*(x+ ~((1#2)*y)))<<=(1#4)
(simpreal (pf "((1#2)*(x+ ~((1#2)*y)))===(1#4)*(4*((1#2)*(x+ ~((1#2)*y))))"))
(simpreal "RealAbsTimes")
(use "RealLeTrans" (pt "abs(1#4)*y"))
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "DivAuxBdR")
(use "0<<=x")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeAbsId")
(autoreal)
(use "xBd")
(ng #t)
(use "RealLeTrans" (pt "RealTimes(1#4)1"))
(use "RealLeMonTimes")
(use "RealNNegPos")
(use "RealLeTrans" (pt "abs y"))
(use "RealLeAbsId")
(autoreal)
(use "CoGToBd")
(use "CoGy")
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
;; ?_13:(1#2)*(x+ ~((1#2)*y))===(1#4)*(4*((1#2)*(x+ ~((1#2)*y))))
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
(save "CoGDivSatCoIClAuxR")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(pp neterm)

;; [ag,ag0]
;;  cCoGToCoGQuad
;;  (cCoGAverage ag(cCoGUMinus(cCoGCompat(cCoGClosureInvH(cCoGToCoH ag0)))))

;; CoGDivSatCoIClAuxL
(set-goal "allnc x,y(CoG x -> CoG y -> (1#4)<<=y -> abs x<<=y -> x<<=0 -> 
 CoG(4*((1#2)*(x+(1#2)*y))))")
(assume "x" "y" "CoGx" "CoGy" "yLBd" "xBd" "x<<=0")
(use "CoGToCoGQuad")
(use "CoGAverage")
(use "CoGx")
(use "CoGClosureInvH")
(use "CoGToCoH")
(use "CoGy")
;; ?_4:abs((1#2)*(x+(1#2)*y))<<=(1#4)
(simpreal (pf "((1#2)*(x+(1#2)*y))===(1#4)*(4*((1#2)*(x+(1#2)*y)))"))
(simpreal "RealAbsTimes")
(use "RealLeTrans" (pt "abs(1#4)*y"))
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "DivAuxBdL")
(use "x<<=0")
(use "xBd")
(ng #t)
(use "RealLeTrans" (pt "RealTimes(1#4)1"))
(use "RealLeMonTimes")
(use "RealNNegPos")
(use "RealLeTrans" (pt "abs y"))
(use "RealLeAbsId")
(autoreal)
(use "CoGToBd")
(use "CoGy")
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
;; ?_10:(1#2)*(x+(1#2)*y)===(1#4)*(4*((1#2)*(x+(1#2)*y)))
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
(save "CoGDivSatCoIClAuxL")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(pp neterm)

;; [ag,ag0]cCoGToCoGQuad(cCoGAverage ag(cCoGClosureInvH(cCoGToCoH ag0)))

;; (set! COMMENT-FLAG #f)
;; CoGDivSatCoICl
(set-goal "allnc x,y(CoG x -> CoG y -> (1#4)<<=y -> abs x<<=y ->
 exr d0,x0(Sd d0 andi CoG x0 andi abs x0<<=y andi
 x*RealUDiv y 3===(1#2)*(x0*RealUDiv y 3+d0)))")
(assume "x" "y" "CoGx" "CoGy" "yLBd" "xBd")
;; Let d1,d2,d3 be the first three digits of x.
;; We first distinguish cases on the most significant digit d1
(inst-with-to "CoGClosure" (pt "x") "CoGx" "CoGClosureInst1")
(elim "CoGClosureInst1")
;; 5,6
(drop "CoGClosureInst1")
(assume "ExHyp1")
(by-assume "ExHyp1" "d1" "d1Prop")
(by-assume "d1Prop" "x1" "d1x1Prop")
(elim "d1x1Prop")
(drop "d1x1Prop")
(assume "Psdd1")
(elim "Psdd1")
;; 18,19
;; Case d1=1
(assume "Conj11")
(elim "Conj11")
(drop "Conj11")
(assume "CoGx1")
(assert "abs x1<<=1")
 (use "CoGToBd")
 (use "CoGx1")
(assume "x1Bd" "Eq1")
(drop "d1x1Prop" "Conj11")
;; Next we show 0<<=x from x===(1#2)*(x1+1)* ~1 using x1Bd
(assert "0<<=x")
 (simpreal "Eq1")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesPlusDistrLeft")
 (ng #t)
 (simpreal "RealTimesIntNOne")
 (use "RealLeTrans" (pt "(1#2)*(RealUMinus 1+1)"))
 (ng #t)
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeAbsInv")
 (autoreal)
 (simpreal "RealAbsUMinus")
 (use "x1Bd")
 (autoreal)
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "0<<=x")
(intro 0 (pt "IntP 1"))
(intro 0 (pt "4*((1#2)*(x+ ~((1#2)*y)))"))
(split)
(use "InitSdSdR")
(split)
(use "CoGDivSatCoIClAuxR")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "0<<=x")
(split)
(use "DivAuxBdR")
(use "0<<=x")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeAbsId")
(autoreal)
(use "xBd")
(use "DivAuxEqR")
(autoreal)
(use "yLBd")
;; 19
;; Case d1=IntN 1
(assume "Conj11")
(elim "Conj11")
(drop "Conj11")
(assume "CoGx1")
(assert "abs x1<<=1")
 (use "CoGToBd")
 (use "CoGx1")
(assume "x1Bd" "Eq1")
;; Next we show x<<=0 from x===(1#2)*(x1+IntN 1)* ~IntN 1 using x1Bd
(assert "x<<=0")
 (simpreal "Eq1")
 (ng #t)
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesOne")
 (use "RealLeTrans" (pt "(1#2)*(RealPlus 1 IntN 1)"))
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeTrans" (pt "abs x1"))
 (use "RealLeAbsId")
 (autoreal)
 (use "x1Bd")
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "x<<=0")
(intro 0 (pt "IntN 1"))
(intro 0 (pt "4*((1#2)*(x+(1#2)*y))"))
(split)
(use "InitSdSdL")
(split)
(use "CoGDivSatCoIClAuxL")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "x<<=0")
(split)
(use "DivAuxBdL")
(use "x<<=0")
(use "xBd")
;; ?_122:x*RealUDiv y 3===(1#2)*(4*((1#2)*(x+(1#2)*y))*RealUDiv y 3+IntN 1)
(use "DivAuxEqL")
(autoreal)
(use "yLBd")
;; 6
(drop "CoGClosureInst1")
(assume "ExHyp")
(by-assume "ExHyp" "x1" "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoHx1")
(assert "abs x1<<=1")
 (use "CoHToBd")
 (use "CoHx1")
(assume "x1Bd" "Eq1")
(inst-with-to "CoHClosure" (pt "x1") "CoHx1" "CoHClosureInst2")
(elim "CoHClosureInst2")
;; 142,143
(drop "CoHClosureInst2")
(assume "ExHyp2")
(by-assume "ExHyp2" "d2" "d2Prop")
(by-assume "d2Prop" "x2" "d2x2Prop")
(elim "d2x2Prop")
(assume "Psdd2")
;; We now distinguish cases on d2
(elim "Psdd2")
;; 153,154
;; Case d1=0, d2=1
(assume "Conj21")
(elim "Conj21")
(drop "Conj21")
(assume "CoGx2")
(assert "abs x2<<=1")
 (use "CoGToBd")
 (use "CoGx2")
(assume "x2Bd" "Eq2")
(drop "d2x2Prop")
;; Next we show 0<<=x from x===(1#2)*(x1+0) and x1===(1#2)*(x2+1)
(assert "0<<=x")
 (simpreal "Eq1")
 (simpreal "Eq2")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesOne")
 (use "RealLeTrans" (pt "(1#2)*((1#2)*(RealUMinus 1+1))"))
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeAbsInv")
 (autoreal)
 (use "x2Bd")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "0<<=x")
;; Now we define d and x0
(intro 0 (pt "IntP 1"))
(intro 0 (pt "4*((1#2)*(x+ ~((1#2)*y)))"))
(split)
(use "InitSdSdR")
(split)
(use "CoGDivSatCoIClAuxR")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "0<<=x")
(split)
;; ?_201:abs(4*((1#2)*(x+ ~((1#2)*y))))<<=y
(use "DivAuxBdR")
(use "0<<=x")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeAbsId")
(autoreal)
(use "xBd")
;; ?_202:x*RealUDiv y 3===(1#2)*(4*((1#2)*(x+ ~((1#2)*y)))*RealUDiv y 3+1)
(use "DivAuxEqR")
(autoreal)
(use "yLBd")
;; 154
(drop "CoHClosureInst2" "d2x2Prop")
;; Case d1=0, d2=IntN 1
(assume "Conj21")
(elim "Conj21")
(drop "Conj21")
(assume "CoGx2")
(assert "abs x2<<=1")
 (use "CoGToBd")
 (use "CoGx2")
(assume "x2Bd" "Eq2")
;; Next we show x<<=0 from x===(1#2)*x1 and x1===(1#2)*(x2+1)*IntN 1
(assert "x<<=0")
 (simpreal "Eq1")
 (simpreal "Eq2")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesIntNOne")
 (simpreal "RealUMinusPlusRat")
 (use "RealLeTrans" (pt "(1#2)*((1#2)*(RealPlus 1 IntN 1))"))
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeTrans" (pt "abs ~x2"))
 (use "RealLeAbsId")
 (autoreal)
 (simpreal "RealAbsUMinus")
 (use "x2Bd")
 (autoreal)
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "x<<=0")
;; Now we define d and x0
(intro 0 (pt "IntN 1"))
(intro 0 (pt "4*((1#2)*(x+(1#2)*y))"))
(split)
(use "InitSdSdL")
(split)
(use "CoGDivSatCoIClAuxL")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "x<<=0")
(split)
;; ?_262:abs(4*((1#2)*(x+(1#2)*y)))<<=y
(use "DivAuxBdL")
(use "x<<=0")
(use "xBd")
(use "DivAuxEqL")
(autoreal)
(use "yLBd")
;; 143
(drop "CoHClosureInst2")
;; Case d1=0, d2=0
(assume "ExHyp2")
(by-assume "ExHyp2" "x2" "Conj21")
(elim "Conj21")
(drop "Conj21")
(assume "CoHx2")
(assert "abs x2<<=1")
 (use "CoHToBd")
 (use "CoHx2")
(assume "x2Bd" "Eq2")
(inst-with-to "CoHClosure" (pt "x2") "CoHx2" "CoHClosureInst3")
(elim "CoHClosureInst3")
;; 283,284
(drop "CoHClosureInst3")
(assume "ExHyp3")
(by-assume "ExHyp3" "d3" "d3Prop")
(by-assume "d3Prop" "x3" "d3x3Prop")
(elim "d3x3Prop")
(drop "d3x3Prop")
(assume "Psdd3")
;; We now distinguish cases on d3
(elim "Psdd3")
;; 296,297
(drop "Psdd3")
;; Case d1=0, d2=0, d3=1
(assume "Conj31")
(elim "Conj31")
(drop "Conj31")
(assume "CoGx3")
(assert "abs x3<<=1")
 (use "CoGToBd")
 (use "CoGx3")
(assume "x3Bd" "Eq3")
;; Next we show 0<<=x from x===(1#2)*x1, x1===(1#2)*x2, x2===(1#2)*(x3+1)*1
(assert "0<<=x")
 (simpreal "Eq1")
 (simpreal "Eq2")
 (simpreal "Eq3")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesOne")
 (use "RealLeTrans" (pt "(1#2)*((1#2)*((1#2)*(RealUMinus 1+1)))"))
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeAbsInv")
 (autoreal)
 (use "x3Bd")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "0<<=x")
;; Now we define d and x0
(intro 0 (pt "IntP 1"))
(intro 0 (pt "4*((1#2)*(x+ ~((1#2)*y)))"))
(split)
(use "InitSdSdR")
(split)
(use "CoGDivSatCoIClAuxR")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "0<<=x")
(split)
;; ?_347:abs(4*((1#2)*(x+ ~((1#2)*y))))<<=y
(use "DivAuxBdR")
(use "0<<=x")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeAbsId")
(autoreal)
(use "xBd")
;; ?_348:x*RealUDiv y 3===(1#2)*(4*((1#2)*(x+ ~((1#2)*y)))*RealUDiv y 3+1)
(use "DivAuxEqR")
(autoreal)
(use "yLBd")
;; 297
;; Case d1=0, d2=0, d3=IntN 1
(assume "Conj32")
(elim "Conj32")
(drop "Conj32")
(assume "CoGx3")
(assert "abs x3<<=1")
 (use "CoGToBd")
 (use "CoGx3")
(assume "x3Bd" "Eq3")
;; Next we show x<<=0 from x===(1#2)*x1, x1===(1#2)*x2, x2===(1#2)*(x3+1)*IntN 1
(assert "x<<=0")
 (simpreal "Eq1")
 (simpreal "Eq2")
 (simpreal "Eq3")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesIntNOne")
 (simpreal "RealUMinusPlusRat")
 (use "RealLeTrans" (pt "(1#2)*((1#2)*((1#2)*(RealPlus 1 IntN 1)))"))
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeTrans" (pt "abs ~x3"))
 (use "RealLeAbsId")
 (autoreal)
 (simpreal "RealAbsUMinus")
 (use "x3Bd")
 (autoreal)
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "x<<=0")
;; Now we define d and x0
(intro 0 (pt "IntN 1"))
(intro 0 (pt "4*((1#2)*(x+(1#2)*y))"))
(split)
(use "InitSdSdL")
(split)
(use "CoGDivSatCoIClAuxL")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "x<<=0")
(split)
;; ?_410:abs(4*((1#2)*(x+(1#2)*y)))<<=y
(use "DivAuxBdL")
(use "x<<=0")
(use "xBd")
(use "DivAuxEqL")
(autoreal)
(use "yLBd")
;; 284
(drop "CoHClosureInst3")
(assume "ExHyp3")
(by-assume "ExHyp3" "x3" "Conj31")
(elim "Conj31")
(drop "Conj31")
(assume "CoHx3")
(assert "abs x3<<=1")
 (use "CoHToBd")
 (use "CoHx3")
(assume "x3Bd" "Eq3")
;; We can now pick d=0 and x0 as 2*x
(intro 0 (pt "0"))
(intro 0 (pt "2*x"))
(split)
(use "InitSdSdM")
(split)
(use "CoGToCoGDouble")
(use "CoGx")
(simpreal "Eq1")
(simpreal "RealAbsTimes")
(ng #t)
(use "RealLeTrans" (pt "RealTimes(1#2)1"))
(use "RealLeMonTimes")
(use"RatNNegToRealNNeg")
(use "Truth")
(use "x1Bd")
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
(split)
;; ?_448:abs(2*x)<<=y
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "Eq1")
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(simpreal "Eq2")
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "Eq3")
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "RealTimesAssoc")
(ng #t)
(use "RealLeTrans" (pt "RealTimes(1#4)1"))
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "x3Bd")
(use "yLBd")
(autoreal)
;; ?_449:x*RealUDiv y 3===(1#2)*(2*x*RealUDiv y 3+0)
(assert "Real(RealUDiv y 3)")
 (use "RealUDivReal")
 (autoreal)
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (use "RealLeTrans" (pt "y")) 
 (use "yLBd")
 (use "RealLeAbsId")
 (autoreal)
 (use "Truth")
(assume "R1/y")
(simpreal "RealPlusZero")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
(save "CoGDivSatCoICl")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; [ag,ag0][case (cCoGClosure ag)
;;    (InL bg -> [case bg
;;      (boole pair ag1 -> [case boole
;;        (True -> SdR pair cCoGDivSatCoIClAuxR ag ag0)
;;        (False -> SdL pair cCoGDivSatCoIClAuxL ag ag0)])])
;;    (InR ah -> [case (cCoHClosure ah)
;;      (InL bg -> [case bg
;;        (boole pair ag1 -> [case boole
;;          (True -> SdR pair cCoGDivSatCoIClAuxR ag ag0)
;;          (False -> SdL pair cCoGDivSatCoIClAuxL ag ag0)])])
;;      (InR ah0 -> [case (cCoHClosure ah0)
;;        (InL bg -> [case bg
;;          (boole pair ag1 -> [case boole
;;            (True -> SdR pair cCoGDivSatCoIClAuxR ag ag0)
;;            (False -> SdL pair cCoGDivSatCoIClAuxL ag ag0)])])
;;        (InR ah1 -> SdM pair cCoGToCoGDouble ag)])])]

;; CoGDivAux
(set-goal "allnc y(CoG y -> (1#4)<<=y -> allnc z(
 exr x(CoG x andi abs x<<=y andi z===x*RealUDiv y 3) -> CoG z))")
(assume "y" "CoGy" "yLBd")
(assert "RealPos y 3")
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (use "yLBd")
 (use "Truth")
(assume "0<y")
(assert "Real(RealUDiv y 3)")
 (use "RealUDivReal")
 (realproof)
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (use "RealLeTrans" (pt "y")) 
 (use "yLBd")
 (use "RealLeAbsId")
 (autoreal)
 (use "Truth")
(assume "R1/y" "x" "ExHyp")
(coind "ExHyp"
       (pf "exr x(CoH x andi abs x<<=y andi z===x*RealUDiv y 3) -> CoH z"))
;; 20,21
(drop "ExHyp")
(assume "x0" "x0Prop")
(by-assume "x0Prop" "x1" "x0x1Prop")
(elim "x0x1Prop")
(drop "x0x1Prop")
(assume "CoGx1" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "x1Bd" "x0Def")
(inst-with-to "CoGDivSatCoICl"
	      (pt "x1") (pt "y") "CoGx1" "CoGy" "yLBd" "x1Bd"
	      "CoGDivInst")
(by-assume "CoGDivInst" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(elim "dx2Prop")
(drop "dx2Prop")
(assume "Sdd")
(assume "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "CoGx2")
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "x2Bd")
(assert "abs(x2*RealUDiv y 3)<<=1")
 (simpreal "RealAbsTimes")
 (use "RealLeTrans" (pt "y*abs(RealUDiv y 3)"))
 (use "RealLeMonTimesL")
 (use "RealNNegAbs")
 (autoreal)
 (use "x2Bd")
 (simpreal "RealAbsUDiv")
 (simpreal "RealNNegToUDivAbs")
 (simpreal "RealTimesUDiv")
 (use "RatLeToRealLe")
 (use "Truth")
 (use "0<y")
 (autoreal)
 (use "RealPosAbs")
 (use "0<y")
 (use "RealPosToNNeg" (pt "3"))
 (autoreal)
 (use "0<y")
 (use "0<y")
 (autoreal)
(assume "x2/yBd")
(assert "d=0 orr Psd d")
 (use-with "SdDisj" (pt "d") "Sdd")
(assume "Disj")
(elim "Disj")
;; 79,80
;; Case d=0
(drop "Disj")
(assume "d=0")
(simp "d=0")
(assume "Eq")
(intro 1) ;go for the r.h.s of the disjunction
(intro 0 (pt "x2*RealUDiv y 3"))
(intro 0 (pt "x0"))
(split)
(autoreal)
(split)
;; ?_90:abs(x2*RealUDiv y 3)<<=1
(use "x2/yBd")
(split)
(intro 1)
(intro 0 (pt "x2"))
(split)
(use "CoGToCoH")
(use "CoGx2")
(split)
(use "x2Bd")
(use "RealEqRefl")
(autoreal)
(split)
(simpreal "x0Def")
(simpreal "Eq")
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 80
;; Case Psd d
(drop "Disj")
(assume "Psdd" "Eq")
(intro 0) ;go for the l.h.s of the disjunction
(intro 0 (pt "d"))
(intro 0 (pt "(x2*RealUDiv y 3)*RealUMinus d"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
;; ?_120:abs(x2*RealUDiv y 3* ~d)<<=1
(simpreal "RealAbsTimes")
(simpreal "RealAbsUMinus")
(simpreal (pf "RealAbs d===1"))
(simpreal "RealTimesOne")
(use "x2/yBd")
(autoreal)
(use "RatEqvToRealEq")
(ng #t)
(use "PsdToAbsOne")
(use "Psdd")
(autoreal)
(split)
(intro 1)
(intro 0 (pt "x2*RealUMinus d"))
(split)
(use "CoGPsdTimes")
(use "CoGx2")
(use "PsdUMinus")
(use "Psdd")
(split)
(simpreal "RealAbsTimes")
(simpreal "RealAbsUMinus")
(use "RealLeTrans" (pt "y*1"))
(use "RealLeMonTimesTwo")
(use "RealNNegAbs")
(autoreal)
(use "RealNNegAbs")
(autoreal)
(use "x2Bd")
(use "RatLeToRealLe")
(ng #t)
(simp "PsdToAbsOne")
(use "Truth")
(use "Psdd")
(simpreal "RealTimesOne")
(use "RealLeRefl")
(autoreal)
(simpreal "RealTimesComm")
(simpreal (pf "x2*RealUMinus d===RealUMinus d*x2"))
(use "RealTimesAssoc")
(autoreal)
(use "RealTimesComm")
(autoreal)
(split)
(simpreal "x0Def")
(simpreal "Eq")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusIntNOneDistrLeft")
(ng #t)
(simpreal "RealTimesPsdPsd")
(use "RealEqRefl")
(autoreal)
(use "PsdUMinus")
(use "Psdd")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 21
(drop "ExHyp")
(assume "x0" "x0Prop")
(by-assume "x0Prop" "x1" "x0x1Prop")
(elim "x0x1Prop")
(drop "x0x1Prop")
(assume "CoHx1" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "x1Bd" "x0Def")
(assert "CoG x1")
 (use "CoHToCoG")
 (use "CoHx1")
(assume "CoGx1")
(inst-with-to "CoGDivSatCoICl"
	      (pt "x1") (pt "y") "CoGx1" "CoGy" "yLBd" "x1Bd"
	      "CoGDivInst")
(by-assume "CoGDivInst" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(elim "dx2Prop")
(drop "dx2Prop")
(assume "Sdd")
(assume "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "CoGx2" "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "x2Bd")
(assert "abs(x2*RealUDiv y 3)<<=1")
 (simpreal "RealAbsTimes")
 (use "RealLeTrans" (pt "y*abs(RealUDiv y 3)"))
 (use "RealLeMonTimesL")
 (use "RealNNegAbs")
 (autoreal)
 (use "x2Bd")
 (simpreal "RealAbsUDiv")
 (simpreal "RealNNegToUDivAbs")
 (simpreal "RealTimesUDiv")
 (use "RatLeToRealLe")
 (use "Truth")
 (use "0<y")
 (autoreal)
 (use "RealPosAbs")
 (use "0<y")
 (use "RealPosToNNeg" (pt "3"))
 (autoreal)
 (use "0<y")
 (use "0<y")
 (autoreal)
(assume "x2/yBd")
(assert "d=0 orr Psd d")
 (use-with "SdDisj" (pt "d") "Sdd")
(assume "Disj")
(elim "Disj")
;; 252,253
;; Case d=0
(drop "Disj")
(assume "d=0")
(simp "d=0")
(assume "Eq")
(intro 1) ;go for the r.h.s of the disjunction
(intro 0 (pt "x2*RealUDiv y 3"))
(intro 0 (pt "x0"))
(split)
(autoreal)
(split)
;; ?_263:abs(x2*RealUDiv y 3)<<=1
(use "x2/yBd")
(split)
(intro 1)
(intro 0 (pt "x2"))
(split)
(use "CoGToCoH")
(use "CoGx2")
(split)
(use "x2Bd")
(use "RealEqRefl")
(autoreal)
(split)
(simpreal "x0Def")
(simpreal "Eq")
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 253
;; Case Psd d
(drop "Disj")
(assume "Psdd" "Eq")
(intro 0) ;go for the l.h.s of the disjunction
(intro 0 (pt "d"))
(intro 0 (pt "(x2*RealUDiv y 3)*d"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
;; ?_293:abs(x2*RealUDiv y 3*d)<<=1
(simpreal "RealAbsTimes")
(simpreal (pf "RealAbs d===1"))
(simpreal "RealTimesOne")
(use "x2/yBd")
(autoreal)
(use "RatEqvToRealEq")
(ng #t)
(use "PsdToAbsOne")
(use "Psdd")
(autoreal)
(split)
(intro 1)
(intro 0 (pt "x2*d"))
(split)
(use "CoGPsdTimes")
(use "CoGx2")
(use "Psdd")
(split)
(simpreal "RealAbsTimes")
(use "RealLeTrans" (pt "y*1"))
(use "RealLeMonTimesTwo")
(use "RealNNegAbs")
(autoreal)
(use "RealNNegAbs")
(autoreal)
(use "x2Bd")
(use "RatLeToRealLe")
(ng #t)
(simp "PsdToAbsOne")
(use "Truth")
(use "Psdd")
(simpreal "RealTimesOne")
(use "RealLeRefl")
(autoreal)
(simpreal "RealTimesComm")
(simpreal (pf "x2*d===d*x2"))
(use "RealTimesAssoc")
(autoreal)
(use "RealTimesComm")
(autoreal)
(split)
(simpreal "x0Def")
(simpreal "Eq")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusOneDistrLeft")
(simpreal "RealTimesPsdPsd")
(use "RealEqRefl")
(autoreal)
(use "Psdd")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
(save "CoGDivAux")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; [ag,ag0]
;;  ([ag1]
;;    [case (cCoGDivSatCoICl ag1 ag)
;;      (s pair ag2 -> [case (cSdDisj s)
;;        (DummyL -> InR(InR(cCoGToCoH ag2)))
;;        (Inr boole -> 
;;          InL(boole pair InR(cCoGPsdTimes ag2(cPsdUMinus boole))))])])
;;  ([ah][case (cCoGDivSatCoICl(cCoHToCoG ah)ag)
;;      (s pair ag1 -> [case (cSdDisj s)
;;        (DummyL -> InR(InR(cCoGToCoH ag1)))
;;        (Inr boole -> InL(boole pair InR(cCoGPsdTimes ag1 boole)))])])

;; CoGDiv
(set-goal
 "allnc x,y(CoG x -> CoG y -> (1#4)<<=y -> abs x<<=y -> CoG(x*RealUDiv y 3))")
(assume "x" "y" "CoGx" "CoGy" "yLBd" "xBd")
(assert "Real(RealUDiv y 3)")
 (use "RealUDivReal")
 (realproof)
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (use "RealLeTrans" (pt "y")) 
 (use "yLBd")
 (use "RealLeAbsId")
 (autoreal)
 (use "Truth")
(assume "R1/y")
(use "CoGDivAux" (pt "y"))
(use "CoGy")
(use "yLBd")
(intro 0 (pt "x"))
(split)
(use "CoGx")
(split)
(use "xBd")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
(save "CoGDiv")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; [ag,ag0]cCoGDivAux ag0 ag


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2017-12-04.  Treatment with Gray code only, without relying on sd.
;; The rest is obsolete

;; 2017-11-27.  examplesanalysisgraydiv.scm

;; (load "~/git/minlog/init.scm")

;; (set! COMMENT-FLAG #f)
;; (libload "nat.scm")
;; (libload "list.scm")
;; (libload "pos.scm")
;; (libload "int.scm")
;; (libload "rat.scm")
;; (remove-var-name "x" "y" "z")
;; (libload "rea.scm")
;; ;; (set! COMMENT-FLAG #t)

;; (load "examplesanalysisJK.scm")
;; ;; (load "~/git/minlog/examples/analysis/JK.scm")

;; (load "examplesanalysisdigits.scm")
;; ;; (load "~/git/minlog/examples/analysis/digits.scm")

;; (load "examplesanalysissdcode.scm")
;; ;; (load "~/git/minlog/examples/analysis/sdcode.scm")

;; (load "examplesanalysissdshift.scm")
;; ;; (load "~/git/minlog/examples/analysis/sdshift.scm")

;; (load "examplesanalysisgraycode.scm")
;; ;; (load "~/git/minlog/examples/analysis/graycode.scm")

;; (load "examplesanalysissdgray.scm")
;; ;; (load "~/git/minlog/examples/analysis/sdgray.scm")

;; (load "examplesanalysisgrayavaux.scm")
;; ;; (load "~/git/minlog/examples/analysis/sdavaux.scm")

;; ;; CoGNegToCoGPlusOne
;; (set-goal "allnc x(exr y(CoG y andi y<<=0 andi x===y+1) -> CoG x)")
;; (assume "x" "ExHyp")
;; (use "CoIToCoG")
;; (by-assume "ExHyp" "y" "yProp")
;; (use "CoINegToCoIPlusOne")
;; (intro 0 (pt "y"))
;; (split)
;; (use "CoGToCoI")
;; (use "yProp")
;; (use "yProp")
;; ;; Proof finished.
;; (save "CoGNegToCoGPlusOne")

;; (define eterm (proof-to-extracted-term))
;; (define neterm (rename-variables (nt eterm)))
;; (pp neterm)
;; ;; [ag]cCoIToCoG(cCoINegToCoIPlusOne(cCoGToCoI ag))

;; ;; CoGPosToCoGMinusOne
;; (set-goal "allnc x(exr y(CoG y andi 0<<=y andi x===y+ ~1) -> CoG x)")
;; (assume "x" "ExHyp")
;; (use "CoIToCoG")
;; (by-assume "ExHyp" "y" "yProp")
;; (use "CoIPosToCoIMinusOne")
;; (intro 0 (pt "y"))
;; (split)
;; (use "CoGToCoI")
;; (use "yProp")
;; (use "yProp")
;; ;; Proof finished.
;; (save "CoGPosToCoGMinusOne")

;; (define eterm (proof-to-extracted-term))
;; (define neterm (rename-variables (nt eterm)))
;; (pp neterm)
;; ;; [ag]cCoIToCoG(cCoIPosToCoIMinusOne(cCoGToCoI ag))

;; ;; CoGToCoGDouble
;; (set-goal "allnc x(CoG x -> abs x<<=(1#2) -> CoG(2*x))")
;; (assume "x" "CoGx" "LeHyp")
;; (inst-with-to "CoGClosure" (pt "x") "CoGx" "CoGClosureInst")
;; (elim "CoGClosureInst")
;; ;; 5,6
;; (drop "CoGClosureInst")
;; (assume "ExHyp")
;; (by-assume "ExHyp" "d" "dProp")
;; (by-assume "dProp" "x1" "dx1Prop")
;; (elim "dx1Prop")
;; (drop "dx1Prop")
;; (assume "Psdd")
;; (elim "Psdd")
;; ;; 18,19
;; ;; Case d=1
;; (assume "Conj")
;; (elim "Conj")
;; (drop "Conj")
;; (assume "CoGx1" "xDef")
;; (simpreal "xDef")
;; (simpreal "RealTimesAssoc")
;; (ng #t)
;; (simpreal "RealTimesIntNOne")
;; (simpreal "RealTimesAssoc")
;; (ng #t)
;; (simpreal "RealOneTimes")
;; (simpreal "RealUMinusPlusRat")
;; (ng #t)
;; (use "CoGNegToCoGPlusOne")
;; (intro 0 (pt "~x1"))
;; (split)
;; (use "CoGUMinus")
;; (simpreal "RealUMinusUMinus")
;; (use "CoGx1")
;; (autoreal)
;; (split)
;; ;;   {x}  CoGx:CoG x
;; ;;   LeHyp:abs x<<=(1#2)
;; ;;   {d}  {x1}  Psdd:Psd d
;; ;;   CoGx1:CoG x1
;; ;;   xDef:x===(1#2)*(x1+IntN 1)* ~1
;; ;; -----------------------------------------------------------------------------
;; ;; ?_49:~x1<<=0
;; (use "RealLeTrans" (pt "2*((1#2)*(x1+IntN 1)* ~1)+ ~1"))
;; ;; 51,52
;; (simpreal "<-" "RealTimesAssoc")
;; (simpreal "RealTimesPlusDistrLeft")
;; (simpreal "RealTimesIdRatUMinus")
;; (simpreal "RealTimesAssoc")
;; (simpreal "RealTimesOne")
;; (ng #t)
;; (simpreal "RealOneTimes")
;; (simpreal "<-" "RealPlusAssoc")
;; (ng #t)
;; (simpreal "RealPlusZero")
;; (use "RealLeRefl")
;; (autoreal)
;; ;; 52
;; (simpreal "<-" "xDef")
;; (use "RealLeTrans" (pt "2*abs x+ ~1"))
;; (use "RealLeMonPlus")
;; (use "RealLeMonTimes")
;; (use "RatNNegToRealNNeg")
;; (use "Truth")
;; (use "RealLeAbsId")
;; (autoreal)
;; (use "RatLeToRealLe")
;; (use "Truth")
;; (use "RealLeTrans" (pt "RealTimes 2(1#2)+ ~1"))
;; (use "RealLeMonPlus")
;; (use "RealLeMonTimes")
;; (use "RatNNegToRealNNeg")
;; (use "Truth")
;; (use "LeHyp")
;; (use "RatLeToRealLe")
;; (use "Truth")
;; (ng #t)
;; (use "RatLeToRealLe")
;; (use "Truth")
;; (use "RealEqRefl")
;; (autoreal)
;; ;; 19
;; ;; Case d= ~1
;; (ng #t)
;; (assume "Conj")
;; (elim "Conj")
;; (drop "Conj")
;; (assume "CoGx1" "xDef")
;; (simpreal "xDef")
;; (simpreal "<-" "RealTimesAssoc")
;; (simpreal "RealTimesOne")
;; (simpreal "RealTimesAssoc")
;; (ng #t)
;; (simpreal "RealOneTimes")
;; (use "CoGPosToCoGMinusOne")
;; (intro 0 (pt "x1"))
;; (split)
;; (use "CoGx1")
;; (split)
;; ;;   {x}  CoGx:CoG x
;; ;;   LeHyp:abs x<<=(1#2)
;; ;;   {d}  {x1}  Psdd:Psd d
;; ;;   CoGx1:CoG x1
;; ;;   xDef:x===(1#2)*(x1+IntN 1)*1
;; ;; -----------------------------------------------------------------------------
;; ;; ?_124:0<<=x1
;; (use "RealLeTrans" (pt "2*((1#2)*(x1+IntN 1)*1)+ 1"))
;; ;; 126,127
;; (simpreal "<-" "xDef")
;; (use "RealLeTrans" (pt "2*RealUMinus(1#2)+1"))
;; (ng #t)
;; (use "RatLeToRealLe")
;; (use "Truth")
;; (use "RealLeMonPlus")
;; (use "RealLeMonTimes")
;; (use "RatNNegToRealNNeg")
;; (use "Truth")
;; (use "RealLeAbsInv")
;; (autoreal)
;; (use "LeHyp")
;; (use "RatLeToRealLe")
;; (use "Truth")
;; ;; 127
;; (simpreal "<-" "RealTimesAssoc")
;; (simpreal "RealTimesOne")
;; (simpreal "RealTimesAssoc")
;; (ng #t)
;; (simpreal "RealOneTimes")
;; (simpreal "<-" "RealPlusAssoc")
;; (ng #t)
;; (simpreal "RealPlusZero")
;; (use "RealLeRefl")
;; (autoreal)
;; (use "RealEqRefl")
;; (autoreal)
;; ;; ?_6:exr x0(CoH x0 andl x===(1#2)*x0) -> CoG(2*x)
;; (drop "CoGClosureInst")
;; (assume "ExHyp")
;; (by-assume "ExHyp" "x1" "Conj")
;; (elim "Conj")
;; (assume "CoHx1" "xDef")
;; (drop "Conj")
;; (simpreal "xDef")
;; (simpreal "RealTimesAssoc")
;; (ng #t)
;; (simpreal "RealOneTimes")
;; (use "CoHToCoG")
;; (use "CoHx1")
;; (autoreal)
;; ;; Proof finished.
;; (save "CoGToCoGDouble")

;; (define eterm (proof-to-extracted-term))
;; (define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; ;; [ag][case (cCoGClosure ag)
;; ;;    (InL bg -> [case bg
;; ;;      (boole pair ag0 -> [case boole
;; ;;        (True -> 
;; ;;        cCoGCompat
;; ;;        (cCoGCompat
;; ;;         (cCoGCompat
;; ;;          (cCoGCompat
;; ;;           (cCoGCompat
;; ;;            (cCoGCompat(cCoGNegToCoGPlusOne(cCoGUMinus(cCoGCompat ag0)))))))))
;; ;;        (False -> 
;; ;;        cCoGCompat
;; ;;        (cCoGCompat
;; ;;         (cCoGCompat(cCoGCompat(cCoGCompat(cCoGPosToCoGMinusOne ag0))))))])])
;; ;;    (InR ah -> cCoGCompat(cCoGCompat(cCoGCompat(cCoHToCoG ah))))]

;; ;; CoGToCoGQuad
;; (set-goal "allnc x(CoG x -> abs x<<=(1#4) -> CoG(4*x))")
;; (assume "x" "CoGx" "LeHyp")
;; (assert "4*x===2*(2*x)")
;; (simpreal "RealTimesAssoc")
;; (ng #t)
;; (use "RealEqRefl")
;; (autoreal)
;; ;; Assertion proved
;; (assume "EqHyp")
;; (simpreal "EqHyp")
;; (use "CoGToCoGDouble")
;; (use "CoGToCoGDouble")
;; (use "CoGx")
;; (use "RealLeTrans" (pt "RealPlus 0(1#4)"))
;; (ng #t)
;; (use "LeHyp")
;; (ng #t)
;; (use "RatLeToRealLe")
;; (use "Truth")
;; (simpreal "RealAbsTimes")
;; (ng #t)
;; (use "RealLeTrans" (pt "RealTimes 2(1#4)"))
;; (use "RealLeMonTimes")
;; (use "RealNNegPos")
;; (use "LeHyp")
;; (use "RatLeToRealLe")
;; (use "Truth")
;; (autoreal)
;; ;; Proof finished.
;; (save "CoGToCoGQuad")

;; (define eterm (proof-to-extracted-term))
;; (define neterm (rename-variables (nt eterm)))
;; (pp neterm)

;; ;; [u]cCoGCompat(cCoGToCoGDouble(cCoGToCoGDouble u))

;; ;; CoIDivSatCoIClAuxBdR CoIDivSatCoIClAuxEqR
;; ;; do not exist here.  Are without CoI !

;; ;; CoIDivSatCoIClAuxR has CoI, but relies only on CoIToCoIQuad CoIAverage
;; ;; (and CoIUMinus CoIClosureInv CoIToBd), which we have for CoG
;; ;; Caution: CoGClosure has no CoGClosureInv 

;; (pp "CoGClosure")
;; ;; allnc x(
;; ;;  CoG x -> 
;; ;;  exr d,x0(Psd d andd CoG x0 andl x===(1#2)*(x0+IntN 1)* ~d) ord 
;; ;;  exr x0(CoH x0 andl x===(1#2)*x0))

;; (pp "CoIClosure")
;; ;; allnc x(
;; ;;  CoI x -> exr d,x0(Sd d andd abs x0<<=1 andr CoI x0 andl x===(1#2)*(x0+d)))

;; (pp "CoIClosureInv")
;; ;; allnc d,x(Sd d -> CoI x -> CoI((1#2)*(x+d)))

;; ;; [It seems that abs x0<<=1 is not needed in CoIClosure: follows from CoIToBd]

;; ;; Attempt:

;; ;; CoGClosureInvG
;; (set-goal "allnc d,x(Psd d -> CoG x -> CoG((1#2)*(x+IntN 1)* ~d))")
;; (assume "d" "x" "Psdd" "CoGx")
;; (use "CoGClauseInv")
;; (intro 0)
;; (intro 0 (pt "d"))
;; (intro 0 (pt "x"))
;; (intro 0 (pt "(1#2)*(x+IntN 1)* ~d"))
;; (split)
;; (use "Psdd")
;; (split)
;; (autoreal)
;; (split)
;; (use "CoGToBd")
;; (use "CoGx")
;; (split)
;; (use "CoGx")
;; (split)
;; (use "RealEqRefl")
;; (autoreal)
;; (use "RealEqRefl")
;; (autoreal)
;; ;; Proof finished.
;; (save "CoGClosureInvG")

;; (define eterm (proof-to-extracted-term))
;; (animate "CoGClauseInv")
;; (define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; ;; [boole,ag]
;; ;;  (CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)
;; ;;  (InL(boole pair ag))
;; ;;  ([bgh]
;; ;;    [case bgh
;; ;;      (InL bg -> InL(clft bg pair InL crht bg))
;; ;;      (InR ah -> InR(InL ah))])
;; ;;  ([bgh]
;; ;;    [case bgh
;; ;;      (InL bg -> InL(clft bg pair InL crht bg))
;; ;;      (InR ah -> InR(InL ah))])

;; (deanimate "CoGClauseInv")

;; (pp "CoGClauseInv")
;; ;; Has a disjunction in the premise.  Split into CoGClauseInvG CoGClauseInvH

;; ;; CoGClauseInvG
;; (set-goal "allnc x(
;;  exr d,x0,y(Psd d andd Real x0 andi abs x0<<=1 
;;             andr CoG x0 andl y===(1#2)*(x0+IntN 1)* ~d andnc x===y) -> CoG x)")
;; (assume "x" "ExHyp")
;; (use "CoGClauseInv")
;; (intro 0)
;; (use "ExHyp")
;; ;; Proof finished.

;; (define eterm (proof-to-extracted-term))
;; (animate "CoGClauseInv")
;; (define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; ;; [bg](CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)(InL bg)
;; ;;  ([bgh][case bgh
;; ;;      (InL bg0 -> InL(clft bg0 pair InL crht bg0))
;; ;;      (InR ah -> InR(InL ah))])
;; ;;  ([bgh][case bgh
;; ;;      (InL bg0 -> InL(clft bg0 pair InL crht bg0))
;; ;;      (InR ah -> InR(InL ah))])

;; (pp "CoHClosure")
